---
import '../styles/global.css';

interface Props {
  title: string;
  description?: string;
}

const { title, description = "Beaucharme Cosmétique - De la graine au flacon" } = Astro.props;
const baseUrl = import.meta.env.BASE_URL;
---

<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self';" />
    <meta http-equiv="X-Frame-Options" content="SAMEORIGIN" />
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <link rel="icon" type="image/x-icon" href={`${baseUrl}/favicon.ico`} />
    <link rel="icon" type="image/png" sizes="32x32" href={`${baseUrl}/favicon-32.png`} />
    <link rel="icon" type="image/png" sizes="16x16" href={`${baseUrl}/favicon-16.png`} />
    <link rel="apple-touch-icon" sizes="192x192" href={`${baseUrl}/favicon-192.png`} />
    <link rel="apple-touch-icon" sizes="512x512" href={`${baseUrl}/favicon-512.png`} />
    <meta name="generator" content={Astro.generator} />
    <title>{title} | Beaucharme Cosmétique</title>
  </head>
  <body class="bg-grain bg-beaucharme-beige">
    <div class="relative z-10">
      <slot />
    </div>

    <script is:inline>
      // Scroll reveal animation
      const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            // Once visible, stop observing (animation plays only once)
            observer.unobserve(entry.target);
          }
        });
      }, observerOptions);

      // Function to observe all animatable elements
      function observeAnimatedElements() {
        document.querySelectorAll('[data-animate]:not(.is-visible)').forEach((el) => {
          observer.observe(el);
        });
      }

      // Initial observation
      observeAnimatedElements();

      // Re-observe when React components hydrate (MutationObserver)
      const mutationObserver = new MutationObserver((mutations) => {
        let shouldObserve = false;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes.length > 0) {
            shouldObserve = true;
          }
        });
        if (shouldObserve) {
          observeAnimatedElements();
        }
      });

      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });

      // Mobile menu toggle
      document.addEventListener('click', (e) => {
        const target = e.target;
        const menuToggle = target.closest('[data-menu-toggle]');
        if (menuToggle) {
          const mobileMenu = document.getElementById('mobile-menu');
          if (mobileMenu) {
            mobileMenu.classList.toggle('hidden');
            document.body.classList.toggle('overflow-hidden');
          }
        }
      });
    </script>
  </body>
</html>
